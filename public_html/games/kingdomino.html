<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@v3.88.2/dist/phaser.min.js"></script>
    <style>
        body {
            background-color: blueviolet;
        }
    </style>
</head>
<body>

    <script>

const config = {
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight,
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
    transparent: true,
    parent: 'game-container',
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

const game = new Phaser.Game(config);

function preload() {
    socket.emit("kingdomino-preload-start");
    
    this.load.image('castle', './images/kingdomino/castle.png');
    this.load.image('background', './images/kingdomino/background.png');

    this.load.image('1', './images/kingdomino/1.png');
    this.load.image('3', './images/kingdomino/3.png');
    this.load.image('8', './images/kingdomino/8.png');
    this.load.image('10', './images/kingdomino/10.png');
    this.load.image('12', './images/kingdomino/12.png');
    this.load.image('13', './images/kingdomino/13.png');
    this.load.image('14', './images/kingdomino/14.png');
    this.load.image('15', './images/kingdomino/15.png');
    this.load.image('16', './images/kingdomino/16.png');
    this.load.image('17', './images/kingdomino/17.png');
    this.load.image('18', './images/kingdomino/18.png');
    this.load.image('19', './images/kingdomino/19.png');
    this.load.image('21', './images/kingdomino/20.png');
    this.load.image('21', './images/kingdomino/21.png');
    this.load.image('22', './images/kingdomino/22.png');
    this.load.image('23', './images/kingdomino/23.png');
    this.load.image('24', './images/kingdomino/24.png');
    this.load.image('28', './images/kingdomino/28.png');
    this.load.image('29', './images/kingdomino/29.png');
    this.load.image('30', './images/kingdomino/30.png');
    this.load.image('31', './images/kingdomino/31.png');
    this.load.image('32', './images/kingdomino/32.png');
    this.load.image('36', './images/kingdomino/36.png');
    this.load.image('37', './images/kingdomino/37.png');
    this.load.image('38', './images/kingdomino/38.png');
    this.load.image('39', './images/kingdomino/39.png');
    this.load.image('40', './images/kingdomino/40.png');
    this.load.image('41', './images/kingdomino/41.png');
    this.load.image('42', './images/kingdomino/42.png');
    this.load.image('43', './images/kingdomino/43.png');
    this.load.image('44', './images/kingdomino/44.png');
    this.load.image('45', './images/kingdomino/45.png');
    this.load.image('46', './images/kingdomino/46.png');
    this.load.image('48', './images/kingdomino/48.png');

    socket.emit("kingdomino-preload-finish");
}

function update() {
    // game loop
}

function create() {
    socket.emit("kingdomino-create-start");
    this.add.rectangle(0, 0, config.width, config.height)
        .setOrigin(0)
        .setStrokeStyle(1, 0xffffff);

    this.add.text(5, 5, 'Kingdomino', { fontSize: '32px', color: '#ffffff' });

    // Create groups
    this.freeTiles = this.add.group();    // tiles you can pick
    this.placedTiles = this.add.group();  // tiles locked on the grid

    // Player grid
    drawPlayerGrid(this, config.width/2, config.height-300, 'YOU', 5, 100, this.placedTiles);

    // Other players (no interactivity needed)
    drawPlayerGrid(this, config.width/2, 110, 'Player 2', 5, 30);
    drawPlayerGrid(this, 180, config.height/2, 'Player 3', 5, 30);
    drawPlayerGrid(this, config.width-180, config.height/2, 'Player 4', 5, 30);

    // Staging area for free tiles
    createFreeTiles(this, [31,69,52,96]);

    // Input listeners
    this.input.on('gameobjectdown', (pointer, gameObject) => {
        if (this.freeTiles.contains(gameObject)) {
            console.log('Picked up free tile');
            this.grabbedTile = gameObject;
        }
    });

    this.input.on('pointermove', (pointer) => {
        if (this.grabbedTile) {
            this.grabbedTile.x = pointer.x;
            this.grabbedTile.y = pointer.y;
        }
    });

    this.input.on('pointerup', (pointer) => {
        if (this.grabbedTile) {
            // Check if inside player's grid
            if (isInsideGrid(this.grabbedTile, config.width/2, config.height-300, 5, 100)) {
                console.log('Placed tile into grid');
                this.grabbedTile.disableInteractive(); // Lock it
                this.freeTiles.remove(this.grabbedTile);
                this.placedTiles.add(this.grabbedTile);

                // Snap to nearest grid square
                snapTileToGrid(this.grabbedTile, config.width/2, config.height-300, 5, 100);
            }
            this.grabbedTile = null;
        }
    });

    // Rotate grabbed tile on right click
    this.input.on('pointerdown', (pointer) => {
        if (pointer.rightButtonDown() && this.grabbedTile) {
            this.grabbedTile.angle += 90;
        }
    });

    socket.emit("kingdomino-create-finish");
}

function drawPlayerGrid(scene, startX, startY, playerName, gridSize, tileSize, placedGroup = null) {
    startX -= (gridSize * tileSize) / 2;
    startY -= (gridSize * tileSize) / 2;
    const graphics = scene.add.graphics({ lineStyle: { width: 1, color: 0xffffff } });

    for (let row = 0; row <= gridSize; row++) {
        graphics.lineBetween(startX, startY + row * tileSize, startX + gridSize * tileSize, startY + row * tileSize);
    }
    for (let col = 0; col <= gridSize; col++) {
        graphics.lineBetween(startX + col * tileSize, startY, startX + col * tileSize, startY + gridSize * tileSize);
    }

    scene.add.text(startX + (gridSize * tileSize) / 2, startY - 20, playerName, { fontSize: '16px', color: '#ffffff' }).setOrigin(0.5);

    // Castle (locked 1x1 tile)
    const castleX = startX + 2 * tileSize;
    const castleY = startY + 2 * tileSize;
    const castle = scene.add.rectangle(castleX + tileSize/2, castleY + tileSize/2, tileSize, tileSize, 0x8888ff)
        .setStrokeStyle(2, 0xffffff)
        .setOrigin(0.5);
    scene.add.image(castleX + tileSize/2, castleY + tileSize/2, 'castle').setOrigin(0.5);

    if (placedGroup) {
        placedGroup.add(castle); // Treat the castle as a placed object
    }
}

socket.on("kingdomino-place-all-tiles", (tiles) => {
    for (let i = 0; i < tiles.length; i++) {
        let tile = scene.add.container(50 + i*100, 50 + Math.floor(i,12)*100); 
        let rectangle = scene.add.rectangle(0,0, 100, 50, 0x00ff00) // 1x2 vertical
            .setStrokeStyle(2, 0x000000)
            .setInteractive();
        let number = scene.add.text(0, 0, tiles[i].left.type + " " + i + " " + tiles[i].right.type, { fontSize: '32px', color: '#000000' }).setOrigin(0.5);
        let image = scene.add.image(0, 0, tiles[i].asset).setOrigin(0.5);
        tile.setData('number', i);
        tile.setData('data', tiles[i]);
        tile.add([rectangle, number, image]);
        scene.freeTiles.add(tile);
    }
});

function createFreeTiles(scene, numbers) {
    // Create some example 1x2 tiles outside the grid
    for (let i = 0; i < numbers.length; i++) {
        let tile = scene.add.container(100 + i * 120, config.height - 100); 
        let rectangle = scene.add.rectangle(0,0, 100, 200, 0x00ff00) // 1x2 vertical
            .setStrokeStyle(2, 0x000000)
            .setInteractive();
        let number = scene.add.text(0, 0, numbers[i], { fontSize: '32px', color: '#000000' }).setOrigin(0.5);
        tile.setData('number', numbers[i]); // Store the number in the tile data
        tile.add([rectangle, number]);
        scene.freeTiles.add(tile);
    }
}

function isInsideGrid(tile, centerX, centerY, gridSize, tileSize) {
    const gridStartX = centerX - (gridSize * tileSize) / 2;
    const gridStartY = centerY - (gridSize * tileSize) / 2;
    const gridEndX = gridStartX + gridSize * tileSize;
    const gridEndY = gridStartY + gridSize * tileSize;

    return (tile.x > gridStartX && tile.x < gridEndX && tile.y > gridStartY && tile.y < gridEndY);
}

function snapTileToGrid(tile, centerX, centerY, gridSize, tileSize) {
    const gridStartX = centerX - (gridSize * tileSize) / 2;
    const gridStartY = centerY - (gridSize * tileSize) / 2;

    const localX = tile.x - gridStartX;
    const localY = tile.y - gridStartY;

    const snappedX = Math.floor(localX / tileSize) * tileSize + tileSize/2 + gridStartX;
    const snappedY = Math.floor(localY / tileSize) * tileSize + tileSize/2 + gridStartY;

    tile.x = snappedX;
    tile.y = snappedY;
}


    </script>

</body>
</html>